* hylab
This repository collects some of the useful functions and macros that
I wrote or borrowed for hylang. I am more accustomed to the common
lisp syntax, so I borrowed from the nice work of riktor on [[https://github.com/riktor/hycl/][hycl]] to 
make hylang more friendly to people coming from common lisp. 

** Installation
To install
#+BEGIN_SRC 
pip install git+https://github.com/guanyilun/hylab/
#+END_SRC

** Examples
To start with, import the core library
#+BEGIN_SRC hy :session :exports code :results none
(import [hylab.core [*]])
(require [hylab.core [*]])
#+END_SRC

#+BEGIN_SRC hy :session :exports both :results output
(setf x 10)
(defun plus-one (x) 
    (inc x)
)
#+END_SRC

#+BEGIN_SRC hy :session :exports both :results output
(print (plus-one x))
#+END_SRC

#+RESULTS:
: 11

Numpy and plt are already loaded by default

#+BEGIN_SRC hy :session :exports both :results output
(print (np.arange 0 10))
#+END_SRC

#+RESULTS:
: [0 1 2 3 4 5 6 7 8 9]

Numpy array indexing can be done by
#+BEGIN_SRC hy :session :exports both :results output
(setf x (np.random.randn 100 100 100))
(nget x 0 1 :10)
#+END_SRC

#+RESULTS:
#+begin_example
array([ 0.87120279, -1.66700778,  0.26169724, -0.60144387,  0.55433208,
       -0.43233873, -1.11727772,  0.41093365,  0.36703862, -1.88770578])
#+end_example

With Ellipsis
#+BEGIN_SRC hy :session :exports both :results output
(. (nget x ... 0:10) shape)
#+END_SRC

#+RESULTS:
: (100, 100, 10)

Add new columns
#+BEGIN_SRC hy :session :exports both :results output
(. (nget x ... None) shape)
#+END_SRC

#+RESULTS:
: (100, 100, 100, 1)

I also wrote a macro that handles a quick python->hy equation
translation which I found very useful. For example, consider this

#+BEGIN_SRC hy :session :exports both :results output
(let ((x (np.linspace 0 10 10)))
    (+ (** (np.sin x) 2) (** (np.cos x) 2)))
#+END_SRC

#+RESULTS:
: ... array([1., 1., 1., 1., 1., 1., 1., 1., 1., 1.])

It can be written as 

#+BEGIN_SRC hy :session :exports both :results output
(let ((x (np.linspace 0 10 10)))
    ($ "np.sin(x)**2+np.cos(x)**2"))
#+END_SRC

#+RESULTS:
: ... array([1., 1., 1., 1., 1., 1., 1., 1., 1., 1.])

This is different to the =py-eval= function as this is a macro that gets
converted into the previous (lisp) notation at compile time instead of
at run time so there is no performance issue. 

More to come ...


** Credits
- Credits to riktor from whom I borrowed lots of codes.
- I also borrowed some codes from Eric Kaschalk. 
- The template is based on cookiecutter-pypackage. 
** License
MIT
